# Rustler BLE playground

```elixir
Mix.install([
  {:kino, "~> 0.14.2"},
  # {:kino_user_presence, "~> 0.1.2"},
  {:rustler_btleplug, "~> 0.0.6-alpha"}
])
```

## Section

```elixir
defmodule RustlerBtleplug.GenserverLiveBook do
  @name :ble_genserver

  @default_timeout 3000

  use GenServer
  require Logger

  defstruct ble: %{peripheral: nil, central: nil, messages: []} frames: %{}, clients: %{a: [], b: []}

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: @name)
  end

  def child_spec(init_arg) do
    Supervisor.child_spec(
      %{
        id: init_arg,
        start: {__MODULE__, :start_link, [init_arg]}
      },
      []
    )
  end

  def init(state) do
    Process.flag(:trap_exit, true)
    # IO.puts("#{__MODULE__} init #{inspect(opts)}")
    {:ok, state, {:continue, :setup}}
  end

  def handle_continue(_, state) do
    {:noreply,
     state
     |> Map.put(:ble, %{
       central: nil,
       peripheral: nil,
       messages: []
     })
     |> Map.put(:frames, %{})
     |> Map.update!(:frames, fn
       frames ->
         frames
         |> Map.put_new(:messages, Kino.Frame.new())

         |> Map.put_new(:peripherals, Kino.Frame.new(placeholder: true))
         # |> Map.put_new(:characteristics, Kino.Frame.new(placeholder: false))
     end)
     |> mount_outer_frame()}
  end

  def mount_outer_frame(state) do
    state.frames.messages |> Kino.render()
  end

  def render_all(state) do
    Kino.Frame.render(state.frames.messages, Kino.Layout.grid(["The A's", state.ble.messages]))
    # Kino.Frame.render(state.frames.cha, Kino.Layout.grid(["The B's", state.clients.b]))
    state
  end

  def handle_info(msg, state) do
    Logger.debug("NIF msg received : #{inspect(msg)}")

    new_state =
      state
      |> update_state_with_message(msg)
      |> render_all()

    {:noreply, new_state}
  end

  def create_central() do
    GenServer.call(@name, {:create_central})
  end

  def start_scan(timeout \\ @default_timeout) do
    Logger.debug("client :start_scan")
    GenServer.cast(@name, {:start_scan, timeout})
  end

  def stop_scan() do
    Logger.debug("client :stop_scan")
    GenServer.cast(@name, {:stop_scan})
  end

  def find_peripheral_by_name(device_name, timeout \\ @default_timeout) do
    Logger.debug("client :find_peripheral_by_name #{device_name}")
    GenServer.call(@name, {:find_peripheral_by_name, device_name, timeout})
  end

  def connect(timeout \\ @default_timeout) do
    Logger.debug("client :connect")
    GenServer.call(@name, {:connect, timeout})
  end

  def subscribe(uuid, timeout \\ @default_timeout) do
    Logger.debug("client :subscribe characteristic uuid: #{uuid}")
    GenServer.call(@name, {:subscribe, uuid, timeout})
  end

  def get_messages() do
    GenServer.call(@name, {:get_messages})
  end

  def handle_cast({:set_central, central_ref}, state) do
    Logger.debug("handle_cast :set_central #{inspect(central_ref)}")

    new_state =
      state
      |> update_in([:ble, :central], fn _central -> central_ref end)

    # |> Map.put(:ble, %{state.ble | central: central_ref})

    Logger.debug("handle_cast :set_central new_state: #{inspect(new_state)}")
    {:noreply, new_state}
  end

  def handle_cast({:start_scan, timeout}, state) do
    Logger.debug("handle_cast :start_scan #{inspect(state)}")

    case state.central do
      nil ->
        Logger.debug("No central reference to start scan.")
        {:noreply, state}

      central_ref ->
        # Call NIF to stop the scan using the central reference
        case RustlerBtleplug.Native.start_scan(central_ref, timeout) do
          {:error, reason} ->
            Logger.debug("Failed to start scan: #{reason}")
            {:noreply, state}

          _central_ref ->
            Logger.debug("Scan Started.")
            Process.sleep(1000)
            {:noreply, state}
        end
    end
  end

  def handle_cast({:stop_scan}, state) do
    Logger.debug("handle_cast :stop_scan #{inspect(state)}")

    case state.central do
      nil ->
        Logger.debug("No central reference to stop scan.")
        {:noreply, state}

      central_ref ->
        # Call NIF to stop the scan using the central reference
        case RustlerBtleplug.Native.stop_scan(central_ref) do
          {:error, reason} ->
            Logger.debug("Failed to stop scan: #{reason}")
            {:noreply, state}

          _central_ref ->
            Logger.debug("Scan Stopped.")
            {:noreply, state}
        end
    end
  end

  def handle_call({:create_central}, _from, state) do
    case RustlerBtleplug.Native.create_central() do
      {:error, reason} ->
        {:error, reason}

      central_ref ->
        GenServer.cast(@name, {:set_central, central_ref})
        Logger.debug("Central Created and Reference Stored!")
        {:reply, {:ok, central_ref}, state}
    end
  end

  def handle_call({:find_peripheral_by_name, device_name, timeout}, _from, state) do
    case state.central do
      nil ->
        Logger.debug("No central reference to find_peripheral_by_name.")
        {:noreply, state}

      central_ref ->
        case RustlerBtleplug.Native.find_peripheral_by_name(central_ref, device_name, timeout) do
          {:error, reason} ->
            Logger.debug("Failed to find #{device_name}: #{reason}")
            {:noreply, state}

          peripheral_ref ->
            Logger.debug("Peripheral #{device_name} found #{inspect(peripheral_ref)}")
            {:reply, {:ok, peripheral_ref}, %{state | peripheral: peripheral_ref}}
        end
    end
  end

  def handle_call({:connect, timeout}, _from, state) do
    case state.peripheral do
      nil ->
        Logger.debug("No peripheral reference to connect.")
        {:noreply, state}

      peripheral_ref ->
        case RustlerBtleplug.Native.connect(peripheral_ref, timeout) do
          {:error, reason} ->
            Logger.debug("Failed to connect to #{inspect(peripheral_ref)}: #{reason}")
            {:noreply, state}

          peripheral_ref ->
            Logger.debug("Connecting to #{inspect(peripheral_ref)}")
            {:reply, {:ok, peripheral_ref}, %{state | peripheral: peripheral_ref}}
        end
    end
  end

  def handle_call({:subscribe, uuid, timeout}, _from, state) do
    case state.peripheral do
      nil ->
        Logger.debug("No peripheral reference to subscribe to.")
        {:noreply, state}

      peripheral_ref ->
        case RustlerBtleplug.Native.subscribe(peripheral_ref, uuid, timeout) do
          {:error, reason} ->
            Logger.debug("Failed to subscribe to #{uuid}: #{reason}")
            {:noreply, state}

          peripheral_ref ->
            Logger.debug("Subscribing to #{uuid} #{inspect(peripheral_ref)}")
            {:reply, {:ok, peripheral_ref}, %{state | peripheral: peripheral_ref}}
        end
    end
  end

  def handle_call({:get_messages}, _from, state) do
    Logger.debug("handle_call :get_messages")
    {:reply, state.messages, state}
  end

  defp update_state_with_message(state, message) do
    state
    |> Map.put(:ble, %{state.ble | messages: [message | state.ble.messages]})
  end
end

```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
ble_device_name = "Pressure"
ble_characteristic_uuid = "61d20a90-71a1-11ea-ab12-0800200c9a66"
default_timeout = 3000

defmodule BleParentSupervisor do
  use Supervisor

  def start_link(init_arg) do
    Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)
  end

  @impl true
  def init(_init_arg) do
    IO.puts("Starting Supervisor: #{inspect(__MODULE__)}")

    children = [
      RustlerBtleplug.GenserverLiveBook
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end
end

if is_pid(Process.whereis(BleParentSupervisor)) do
  Supervisor.stop(BleParentSupervisor)
end

# Start the supervision tree
sup_pid = BleParentSupervisor.start_link([])

# Process.alive?(:ble_genserver)
# Output the supervision tree
Kino.Process.sup_tree(BleParentSupervisor)

Kino.Process.render_seq_trace(self(), fn ->
  {:ok, central_ref} = RustlerBtleplug.GenserverLiveBook.create_central()

  IO.puts("Is central_ref a reference: #{inspect(is_reference(central_ref))}")
  RustlerBtleplug.GenserverLiveBook.start_scan(default_timeout)
  RustlerBtleplug.GenserverLiveBook.find_peripheral_by_name(ble_device_name, 10000)

  Process.sleep(10000)
  RustlerBtleplug.GenserverLiveBook.connect(default_timeout)
  RustlerBtleplug.GenserverLiveBook.subscribe(ble_characteristic_uuid, default_timeout)
end)

# Kino.Process.app_tree(:logger)
# RustlerBtleplug.Demo.start()
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
require Logger
alias RustlerBtleplug.Native

defmodule RustlerBtleplug.Demo do
  def start(
        device_name \\ "Pressure",
        characteristic_uuid \\ "61d20a90-71a1-11ea-ab12-0800200c9a66"
      ) do
    central = Native.create_central()
    central = Native.start_scan(central, 5000)
    # Process.sleep(500)
    # peripheral = Native.find_peripheral_by_name(central, device_name)
    # peripheral = Native.find_peripheral(central, "uuid")
    Process.sleep(500)

    # peripheral = Native.connect(peripheral)
    # _peripheral = Native.subscribe(peripheral, characteristic_uuid)

    Process.sleep(1000)

    # peripheral = Native.disconnect(peripheral)
    # Native.unsubscribe(peripheral, "61d20a90-71a1-11ea-ab12-0800200c9a66")
  end
end
```
